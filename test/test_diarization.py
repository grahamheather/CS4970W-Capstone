import pytest

# supporting libraries
from os import path
import pickle
import wave
import numpy
import multiprocessing


# file under test
from CAT import record

# testing file generation
import gen_audio

# this process can be slow
# it can be disabled if settings have not been changed (the necessary files are saved)
REGENERATE_FILES = False
NUMBER_OF_FEATURES = 26

# UTILITY FUNCTIONS

def get_test_recording_dir():
	return path.join('test', 'test_recordings')

def read_wav(filename):
	wave_file = wave.open(filename, 'r')
	return wave_file.readframes(wave_file.getnframes())


# FIXTURES

@pytest.fixture(scope="session", autouse=True)
def generate_audio_files():
	if REGENERATE_FILES:
		stats = gen_audio.generate_test_diarization_audio(get_test_recording_dir())
		with open(path.join(get_test_recording_dir(), 'test_diarization_stats.pickle'), 'wb') as f:
			pickle.dump(stats, f)
	else:
		with open(path.join(get_test_recording_dir(), 'test_diarization_stats.pickle'), 'rb') as f:
			stats = pickle.load(f)

	return stats


# TESTS

# test separating 2 different speakers
# ignore warnings generated by pyAudioAnalysis
@pytest.mark.filterwarnings("ignore:")
def test_split_by_speaker_normal(generate_audio_files):
	result, means, covariances = record.split_by_speaker(path.join(get_test_recording_dir(), "diarization_normal.wav"))

	# check valid shape output of parameters
	assert means.shape[0] == covariances.shape[0]
	assert means.shape[1] == NUMBER_OF_FEATURES
	assert covariances.shape[1] == NUMBER_OF_FEATURES
	assert covariances.shape[2] == NUMBER_OF_FEATURES
	assert max(result.keys()) <= means.shape[0]

	valid_speakers = [speaker for speaker in result if len(result[speaker]) > 0]
	assert len(valid_speakers) == 2
	
	assert len(result[valid_speakers[0]]) == 1
	assert len(result[valid_speakers[1]]) == 1

	segment1 = result[valid_speakers[0]][0]
	segment2 = result[valid_speakers[1]][0]

	audio = read_wav(path.join(get_test_recording_dir(), "diarization_normal.wav"))
	(start1, end1), (start2, end2) = generate_audio_files["normal"]
	desired_speech1 = audio[start1 + 10000:end1 - 10000]
	desired_speech2 = audio[start2 + 10000:end2 - 10000]

	if desired_speech1 in segment1:
		assert desired_speech2 in segment2
	else:
		assert desired_speech1 in segment2
		assert desired_speech2 in segment1


# test separating 2 different speakers with the addition of background noise
# ignore warnings generated by pyAudioAnalysis
@pytest.mark.filterwarnings("ignore:")
def test_split_by_speaker_noise(generate_audio_files):
	result, means, covariances = record.split_by_speaker(path.join(get_test_recording_dir(), "diarization_noise.wav"))
	
	# check valid shape output of parameter
	assert means.shape[0] == covariances.shape[0]
	assert means.shape[1] == NUMBER_OF_FEATURES
	assert covariances.shape[1] == NUMBER_OF_FEATURES
	assert covariances.shape[2] == NUMBER_OF_FEATURES
	assert max(result.keys()) <= means.shape[0]

	valid_speakers = [speaker for speaker in result if len(result[speaker]) > 0]
	assert len(valid_speakers) == 2
	
	assert len(result[valid_speakers[0]]) == 1
	assert len(result[valid_speakers[1]]) == 1

	segment1 = result[valid_speakers[0]][0]
	segment2 = result[valid_speakers[1]][0]

	audio = read_wav(path.join(get_test_recording_dir(), "diarization_noise.wav"))
	(start1, end1), (start2, end2) = generate_audio_files["noise"]
	desired_speech1 = audio[start1 + 20000:end1 - 20000]
	desired_speech2 = audio[start2 + 20000:end2 - 20000]
	
	if desired_speech1 in segment1:
		assert desired_speech2 in segment2
	else:
		assert desired_speech1 in segment2
		assert desired_speech2 in segment1


# test not separating 1 speaker
# ignore warnings generated by pyAudioAnalysis
@pytest.mark.filterwarnings("ignore:")
def test_split_by_speaker_single(generate_audio_files):
	result, means, covariances = record.split_by_speaker(path.join(get_test_recording_dir(), "diarization_single.wav"))
	
	# check valid shape output of parameters
	assert means.shape[0] == covariances.shape[0]
	assert means.shape[1] == NUMBER_OF_FEATURES
	assert covariances.shape[1] == NUMBER_OF_FEATURES
	assert covariances.shape[2] == NUMBER_OF_FEATURES
	assert max(result.keys()) <= means.shape[0]

	valid_speakers = [speaker for speaker in result if len(result[speaker]) > 0]
	assert len(valid_speakers) == 1
	
	assert len(result[valid_speakers[0]]) == 1

	segment = result[valid_speakers[0]][0]

	audio = read_wav(path.join(get_test_recording_dir(), "diarization_single.wav"))
	start, end = generate_audio_files["single"]
	desired_speech = audio[start + 10000:end - 10000]

	assert desired_speech in segment



# test not separating 1 speaker with the addition of background noise
# ignore warnings generated by pyAudioAnalysis
@pytest.mark.filterwarnings("ignore:")
def test_split_by_speaker_single_noise(generate_audio_files):
	result, means, covariances = record.split_by_speaker(path.join(get_test_recording_dir(), "diarization_single_noise.wav"))
	
	# check valid shape output of parameters
	assert means.shape[0] == covariances.shape[0]
	assert means.shape[1] == NUMBER_OF_FEATURES
	assert covariances.shape[1] == NUMBER_OF_FEATURES
	assert covariances.shape[2] == NUMBER_OF_FEATURES
	assert max(result.keys()) <= means.shape[0]

	valid_speakers = [speaker for speaker in result if len(result[speaker]) > 0]
	assert len(valid_speakers) == 1
	
	assert len(result[valid_speakers[0]]) == 1

	segment = result[valid_speakers[0]][0]

	audio = read_wav(path.join(get_test_recording_dir(), "diarization_single_noise.wav"))
	start, end = generate_audio_files["single_noise"]
	desired_speech = audio[start + 10000:end - 10000]

	assert desired_speech in segment


def test_KL_divergence_same():
	# test that KL divergence of two identical gaussians is 0
	mean = numpy.array([[1], [0], [0]])
	covariance = numpy.array([[1, 6, 0],
							 [6, 4, 1],
							 [0, 1, 4]
							 ])
	result = record.multivariate_normal_KL_divergence(mean, covariance, mean, covariance)
	assert result == 0


def test_KL_divergence_valid():
	# test KL divergence on an arbitrary pair of Gaussians
	mean1 = numpy.array([[1], [0]])
	mean0 = numpy.array([[0], [1]])
	covariance1 = [[1, 0], [0, 1]]
	covariance0 = [[2, .5], [.5, 2]]
	result = record.multivariate_normal_KL_divergence(mean0, covariance0, mean1, covariance1)
	assert abs(result - 1.33912) < .00001


def test_KL_divergence_invalid():
	# test KL divergence on a singular matrix
	mean = numpy.array([[1], [0]])
	covariance = numpy.array([[1, 2],
							  [2, 4]
							 ])
	result = record.multivariate_normal_KL_divergence(mean, covariance, mean, covariance)
	assert result == numpy.inf


def test_identify_speaker_empty():
	# test that a new speaker can be added with no previous speakers
	mean = numpy.array([[1], [0]])
	covariance = numpy.array([[1, 0], [0, 1]])
	dictionary = {}
	lock = multiprocessing.Lock()
	result = record.identify_speaker(mean, covariance, dictionary, lock)
	assert len(dictionary) == 1
	assert result in dictionary
	assert dictionary[result] == (mean, covariance, 1)


def test_identify_speaker_previous():
	# check that a speaker can be compared against previous speakers
	mean = numpy.array([[1], [0]])
	covariance = numpy.array([[1, 0], [0, 1]])
	dictionary = {
		'abc': (
			numpy.array([[1.5], [0]]), 
			numpy.array([[1, 0], [0, 1]]), 
			3
		),
		'xyz': (
			numpy.array([[5], [0]]), 
			numpy.array([[1, 0], [0, 1]]), 
			3
		)
	}
	lock = multiprocessing.Lock()
	result = record.identify_speaker(mean, covariance, dictionary, lock)
	assert len(dictionary) == 2
	assert result == 'abc'
	assert len(dictionary[result]) == 3
	assert (dictionary[result][0] == numpy.array([[1.375], [0]])).all()
	assert (dictionary[result][1] == numpy.array([[1, 0], [0, 1]])).all()
	assert dictionary[result][2] == 4


def test_identify_speaker_invalid_previous():
	# check that a speaker can be compared against previous speakers
	# including ones with singular matrices
	mean = numpy.array([[1], [0]])
	covariance = numpy.array([[1, 0], [0, 1]])
	dictionary = {
		'abc': (
			numpy.array([[1.5], [0]]), 
			numpy.array([[1, 0], [0, 1]]), 
			3),
		'xyz': (
			numpy.array([[1.5], [0]]),
			numpy.array([[1, 1], [1, 1]]), 
			5
		)
	}
	lock = multiprocessing.Lock()
	result = record.identify_speaker(mean, covariance, dictionary, lock)
	assert len(dictionary) == 2
	assert result == 'abc'
	assert len(dictionary[result]) == 3
	assert (dictionary[result][0] == numpy.array([[1.375], [0]])).all()
	assert (dictionary[result][1] == numpy.array([[1, 0], [0, 1]])).all()
	assert dictionary[result][2] == 4


def test_identify_speaker_new():
	# check that a new speaker can be identified from previous speakers
	# including ones with singular matrices
	mean = numpy.array([[1], [0]])
	covariance = numpy.array([[1, 0], [0, 1]])
	dictionary = {
		'abc': (
			numpy.array([[1000000], [0]]), 
			numpy.array([[1, 0], [0, 1]]), 
			3),
		'xyz': (
			numpy.array([[-1000000], [0]]),
			numpy.array([[1, 0], [0, 1]]), 
			5
		)
	}
	lock = multiprocessing.Lock()
	result = record.identify_speaker(mean, covariance, dictionary, lock)
	assert len(dictionary) == 3
	assert (not result == 'abc') and (not result == 'xyz')
	assert len(dictionary[result]) == 3
	assert (dictionary[result][0] == numpy.array([[1], [0]])).all()
	assert (dictionary[result][1] == numpy.array([[1, 0], [0, 1]])).all()
	assert dictionary[result][2] == 1


def test_identify_speaker_invalid_new():
	# check that a new speaker can be identified from previous speakers
	# including ones with singular matrices
	mean = numpy.array([[1], [0]])
	covariance = numpy.array([[1, 0], [0, 1]])
	dictionary = {
		'abc': (
			numpy.array([[1000000], [0]]), 
			numpy.array([[1, 0], [0, 1]]), 
			3),
		'xyz': (
			numpy.array([[1.5], [0]]),
			numpy.array([[1, 1], [1, 1]]), 
			5
		)
	}
	lock = multiprocessing.Lock()
	result = record.identify_speaker(mean, covariance, dictionary, lock)
	assert len(dictionary) == 3
	assert (not result == 'abc') and (not result == 'xyz')
	assert len(dictionary[result]) == 3
	assert (dictionary[result][0] == numpy.array([[1], [0]])).all()
	assert (dictionary[result][1] == numpy.array([[1, 0], [0, 1]])).all()
	assert dictionary[result][2] == 1


def test_analyze_audio_file_previous_speaker():
	# INSERT TEST HERE ONCE ANALYZE_AUDIO_FILE IS COMPLETE!
	assert True


def test_analyze_audio_file_new_speaker():
	# INSERT TEST HERE ONCE ANLYZE_AUDIO_FILE IS COMPLETE!
	assert True