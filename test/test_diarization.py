import pytest

# supporting libraries
from os import path
import pickle
import wave
import numpy
import multiprocessing

# file under test
from CAT import record

# testing file generation
import gen_audio

# this process can be slow
# it can be disabled if settings have not been changed (the necessary files are saved)
REGENERATE_FILES = False
NUMBER_OF_FEATURES = 26

# UTILITY FUNCTIONS

def get_test_recording_dir():
	return path.join('test', 'test_recordings')

def read_wav(filename):
	wave_file = wave.open(filename, 'r')
	return wave_file.readframes(wave_file.getnframes())


# FIXTURES

@pytest.fixture(scope="session", autouse=True)
def generate_audio_files():
	if REGENERATE_FILES:
		stats = gen_audio.generate_test_diarization_audio(get_test_recording_dir())
		with open(path.join(get_test_recording_dir(), 'test_diarization_stats.pickle'), 'wb') as f:
			pickle.dump(stats, f)
	else:
		with open(path.join(get_test_recording_dir(), 'test_diarization_stats.pickle'), 'rb') as f:
			stats = pickle.load(f)

	return stats


# TESTS

# test separating 2 different speakers
# ignore warnings generated by pyAudioAnalysis
@pytest.mark.filterwarnings("ignore:")
def test_split_by_speaker_normal(generate_audio_files):
	result, means, covariances = record.split_by_speaker(path.join(get_test_recording_dir(), "diarization_normal.wav"))

	# check valid shape output of parameters
	assert means.shape[0] == covariances.shape[0]
	assert means.shape[1] == NUMBER_OF_FEATURES
	assert covariances.shape[1] == NUMBER_OF_FEATURES
	assert covariances.shape[2] == NUMBER_OF_FEATURES
	assert max(result.keys()) <= means.shape[0]

	valid_speakers = [speaker for speaker in result if len(result[speaker]) > 0]
	assert len(valid_speakers) == 2
	
	assert len(result[valid_speakers[0]]) == 1
	assert len(result[valid_speakers[1]]) == 1

	segment1 = result[valid_speakers[0]][0]
	segment2 = result[valid_speakers[1]][0]

	audio = read_wav(path.join(get_test_recording_dir(), "diarization_normal.wav"))
	(start1, end1), (start2, end2) = generate_audio_files["normal"]
	desired_speech1 = audio[start1 + 15000:end1 - 15000]
	desired_speech2 = audio[start2 + 15000:end2 - 15000]

	if desired_speech1 in segment1:
		assert desired_speech2 in segment2
	else:
		assert desired_speech1 in segment2
		assert desired_speech2 in segment1


# test separating 2 different speakers with the addition of background noise
# ignore warnings generated by pyAudioAnalysis
@pytest.mark.filterwarnings("ignore:")
def test_split_by_speaker_noise(generate_audio_files):
	result, means, covariances = record.split_by_speaker(path.join(get_test_recording_dir(), "diarization_noise.wav"))
	
	# check valid shape output of parameter
	assert means.shape[0] == covariances.shape[0]
	assert means.shape[1] == NUMBER_OF_FEATURES
	assert covariances.shape[1] == NUMBER_OF_FEATURES
	assert covariances.shape[2] == NUMBER_OF_FEATURES
	assert max(result.keys()) <= means.shape[0]

	valid_speakers = [speaker for speaker in result if len(result[speaker]) > 0]
	assert len(valid_speakers) == 2
	
	assert len(result[valid_speakers[0]]) == 1
	assert len(result[valid_speakers[1]]) == 1

	segment1 = result[valid_speakers[0]][0]
	segment2 = result[valid_speakers[1]][0]

	audio = read_wav(path.join(get_test_recording_dir(), "diarization_noise.wav"))
	(start1, end1), (start2, end2) = generate_audio_files["noise"]
	desired_speech1 = audio[start1 + 20000:end1 - 20000]
	desired_speech2 = audio[start2 + 20000:end2 - 20000]
	
	if desired_speech1 in segment1:
		assert desired_speech2 in segment2
	else:
		assert desired_speech1 in segment2
		assert desired_speech2 in segment1


# test not separating 1 speaker
# ignore warnings generated by pyAudioAnalysis
@pytest.mark.filterwarnings("ignore:")
def test_split_by_speaker_single(generate_audio_files):
	result, means, covariances = record.split_by_speaker(path.join(get_test_recording_dir(), "diarization_single.wav"))
	
	# check valid shape output of parameters
	assert means.shape[0] == covariances.shape[0]
	assert means.shape[1] == NUMBER_OF_FEATURES
	assert covariances.shape[1] == NUMBER_OF_FEATURES
	assert covariances.shape[2] == NUMBER_OF_FEATURES
	assert max(result.keys()) <= means.shape[0]

	valid_speakers = [speaker for speaker in result if len(result[speaker]) > 0]
	assert len(valid_speakers) == 1
	
	assert len(result[valid_speakers[0]]) == 1

	segment = result[valid_speakers[0]][0]

	audio = read_wav(path.join(get_test_recording_dir(), "diarization_single.wav"))
	start, end = generate_audio_files["single"]
	desired_speech = audio[start + 10000:end - 10000]

	assert desired_speech in segment



# test not separating 1 speaker with the addition of background noise
# ignore warnings generated by pyAudioAnalysis
@pytest.mark.filterwarnings("ignore:")
def test_split_by_speaker_single_noise(generate_audio_files):
	result, means, covariances = record.split_by_speaker(path.join(get_test_recording_dir(), "diarization_single_noise.wav"))
	
	# check valid shape output of parameters
	assert means.shape[0] == covariances.shape[0]
	assert means.shape[1] == NUMBER_OF_FEATURES
	assert covariances.shape[1] == NUMBER_OF_FEATURES
	assert covariances.shape[2] == NUMBER_OF_FEATURES
	assert max(result.keys()) <= means.shape[0]

	valid_speakers = [speaker for speaker in result if len(result[speaker]) > 0]
	assert len(valid_speakers) == 1
	
	assert len(result[valid_speakers[0]]) == 1

	segment = result[valid_speakers[0]][0]

	audio = read_wav(path.join(get_test_recording_dir(), "diarization_single_noise.wav"))
	start, end = generate_audio_files["single_noise"]
	desired_speech = audio[start + 10000:end - 10000]

	assert desired_speech in segment


# test that distance between two identical speakers is 0
def test_speaker_distance_same():
	mean = numpy.array([[1], [0], [0]])
	covariance = numpy.array([[1, 6, 0],
							 [6, 4, 1],
							 [0, 1, 4]
							 ])
	result = record.speaker_distance(mean, covariance, mean, covariance)
	assert result == 0


# test distance an arbitrary pair of speakers
# CURRENTLY EUCLIDEAN DISTANCE
def test_speaker_distance_valid():
	mean1 = numpy.array([[1], [0]])
	mean0 = numpy.array([[2], [0]])
	covariance1 = [[1, 0], [0, 1]]
	covariance0 = [[2, .5], [.5, 2]]
	result = record.speaker_distance(mean0, covariance0, mean1, covariance1)
	assert abs(result - 1) < .00001


# test a singular matrix does not cause an error
def test_speaker_distance_singlar():
	mean = numpy.array([[1], [0]])
	covariance = numpy.array([[1, 2],
							  [2, 4]
							 ])
	result = record.speaker_distance(mean, covariance, mean, covariance)


# test that a new speaker can be added with no previous speakers
def test_identify_speaker_empty():
	mean = numpy.array([[1], [0]])
	covariance = numpy.array([[1, 0], [0, 1]])
	dictionary = {}
	lock = multiprocessing.Lock()
	result = record.identify_speaker(mean, covariance, dictionary, lock)
	assert len(dictionary) == 1
	assert result in dictionary
	assert dictionary[result] == (mean, covariance, 1)


# test that a speaker can be compared against previous speakers
def test_identify_speaker_previous():
	mean = numpy.array([[1], [0]])
	covariance = numpy.array([[1, 0], [0, 1]])
	dictionary = {
		'abc': (
			numpy.array([[1.5], [0]]), 
			numpy.array([[1, 0], [0, 1]]), 
			3
		),
		'xyz': (
			numpy.array([[5], [0]]), 
			numpy.array([[1, 0], [0, 1]]), 
			3
		)
	}
	lock = multiprocessing.Lock()
	result = record.identify_speaker(mean, covariance, dictionary, lock)
	assert len(dictionary) == 2
	assert result == 'abc'
	assert len(dictionary[result]) == 3
	assert (dictionary[result][0] == numpy.array([[1.375], [0]])).all()
	assert (dictionary[result][1] == numpy.array([[1, 0], [0, 1]])).all()
	assert dictionary[result][2] == 4


# test that a speaker can be compared against previous speakers
# including ones with singular matrices
def test_identify_speaker_invalid_previous():
	mean = numpy.array([[1], [0]])
	covariance = numpy.array([[1, 0], [0, 1]])
	dictionary = {
		'abc': (
			numpy.array([[1.5], [0]]), 
			numpy.array([[1, 0], [0, 1]]), 
			3),
		'xyz': (
			numpy.array([[1.5], [0]]),
			numpy.array([[1, 1], [1, 1]]), 
			5
		)
	}
	lock = multiprocessing.Lock()
	result = record.identify_speaker(mean, covariance, dictionary, lock)
	assert len(dictionary) == 2
	assert result == 'abc'
	assert len(dictionary[result]) == 3
	assert (dictionary[result][0] == numpy.array([[1.375], [0]])).all()
	assert (dictionary[result][1] == numpy.array([[1, 0], [0, 1]])).all()
	assert dictionary[result][2] == 4


# te that a new speaker can be identified from previous speakers
# including ones with singular matrices
def test_identify_speaker_new():
	mean = numpy.array([[1], [0]])
	covariance = numpy.array([[1, 0], [0, 1]])
	dictionary = {
		'abc': (
			numpy.array([[1000000000], [0]]), 
			numpy.array([[1, 0], [0, 1]]), 
			3),
		'xyz': (
			numpy.array([[-1000000000], [0]]),
			numpy.array([[1, 0], [0, 1]]), 
			5
		)
	}
	lock = multiprocessing.Lock()
	result = record.identify_speaker(mean, covariance, dictionary, lock)
	assert len(dictionary) == 3
	assert (not result == 'abc') and (not result == 'xyz')
	assert len(dictionary[result]) == 3
	assert (dictionary[result][0] == numpy.array([[1], [0]])).all()
	assert (dictionary[result][1] == numpy.array([[1, 0], [0, 1]])).all()
	assert dictionary[result][2] == 1


# test that a new speaker can be identified from previous speakers
# including ones with singular matrices	
def test_identify_speaker_invalid_new():
	mean = numpy.array([[1], [0]])
	covariance = numpy.array([[1, 0], [0, 1]])
	dictionary = {
		'abc': (
			numpy.array([[1000000000], [0]]), 
			numpy.array([[1, 0], [0, 1]]), 
			3
		),
		'xyz': (
			numpy.array([[-100000000], [0]]),
			numpy.array([[1, 1], [1, 1]]), 
			5
		)
	}
	lock = multiprocessing.Lock()
	result = record.identify_speaker(mean, covariance, dictionary, lock)
	assert len(dictionary) == 3
	assert (not result == 'abc') and (not result == 'xyz')
	assert len(dictionary[result]) == 3
	assert (dictionary[result][0] == numpy.array([[1], [0]])).all()
	assert (dictionary[result][1] == numpy.array([[1, 0], [0, 1]])).all()
	assert dictionary[result][2] == 1


# Test that a previously seen speaker can be identified in a new recording
@pytest.mark.filterwarnings("ignore:")
def test_identify_speakers_same_recording(generate_audio_files):
	# The speaker diarization module is unstable.
	# It is provided as an extra feature to be improved and developed upon.
	# As such the realistic tests for it are equally unstable.
	# Prior tests guarantee that the code functions apporpriately in simplistic cases.
	# These tests check that the entire section is assembled properly and can return the correct answers.
	# Multiple runs are calculated to ensure that the tests should (almost) always pass.
	runs = []
	for _ in range(5):
		tests = []

		filename = path.join(get_test_recording_dir(), "diarization_same_recording.wav")
		dictionary = {}
		lock = multiprocessing.Lock()

		# check that the first new speaker is identified properly
		result1 = record.identify_speakers(filename, dictionary, lock)
		speakers1 = set(speaker for file, speaker in result1)
		tests.append(len(dictionary) == 1)
		tests.append(len(speakers1) == 1)
		tests.append(list(dictionary.keys())[0] in speakers1)

		# check that that speaker is re-identified propery as well
		# (in an identical recording)
		result = record.identify_speakers(filename, dictionary, lock)
		speakers = set(speaker for file, speaker in result)
		tests.append(len(dictionary) == 1)
		tests.append(len(speakers) == 1)
		tests.append(list(dictionary.keys())[0] in speakers)

		runs.append(all(tests))

	assert any(runs)


# Test differentiating a new speaker from previously seen ones in recordings
@pytest.mark.filterwarnings("ignore:")
def test_identify_speakers_new_speaker(generate_audio_files):
	# The speaker diarization module is unstable.
	# It is provided as an extra feature to be improved and developed upon.
	# As such the realistic tests for it are equally unstable.
	# Prior tests guarantee that the code functions apporpriately in simplistic cases.
	# These tests check that the entire section is assembled properly and can return the correct answers.
	# Multiple runs are calculated to ensure that the tests should (almost) always pass.
	runs = []
	for _ in range(5):
		tests = []

		filename1 = path.join(get_test_recording_dir(), "diarization_same_recording.wav")
		filename2 = path.join(get_test_recording_dir(), "diarization_two_speakers.wav")
		dictionary = {}
		lock = multiprocessing.Lock()

		# check that the first new speaker is identified properly
		result1 = record.identify_speakers(filename1, dictionary, lock)
		speakers1 = set(speaker for file, speaker in result1)
		tests.append(len(dictionary) == 1)
		tests.append(len(speakers1) == 1)
		tests.append(list(dictionary.keys())[0] in speakers1)

		# check that that speaker is re-identified propery as well
		# (in an identical recording)
		result2 = record.identify_speakers(filename2, dictionary, lock)
		speakers2 = set(speaker for file, speaker in result2)
		tests.append(len(dictionary) == 2)
		tests.append(len(speakers2) == 2)
		tests.append(any(speaker in speakers1 for speaker in speakers2))

		runs.append(all(tests))
	assert any(runs)